
from data_types import SPEAKER_MAPPING


def jsonify_transcription(transcription):
    """
    Unify a speaker-aware transcription represented as
    a list of `(speaker: int, text: str)` pairs
    into a single text colored by speakers.
    """
    result = []
    for speaker, text, start, end in transcription:
        # Get the mapping for the speaker number. If one doesn't exist, use the speaker number itself.
        result.append({"speaker": SPEAKER_MAPPING.get(speaker, speaker), "text": text, "start": start, "end": end})

    return result


def reformat_chunk(chunk):
    """
    Reformat a chunk to be of type float32 as required by Whisper
    """
    return chunk.data.astype("float32").reshape(-1)


def concatenate_segments(segments):
    """
    Concatenate the segments from faster-whisper into a single string
    """
    transcription_text = ""
    for segment in segments:
        transcription_text += segment.text
    return transcription_text


def jsonify_word(word):
    """
    Convert a faster-whisper word object into a JSON object
    """
    return {
        "word": word.word,
        "start": word.start,
        "end": word.end,
        "probability": word.probability,
        "tokens": None
    }


def jsonify_segment(segment):
    """
    Convert a faster-whisper segment object into a JSON object
    """
    return {
        "seek": segment.seek,
        "start": segment.start,
        "end": segment.end,
        "text": segment.text,
        "tokens": segment.tokens,
        "temperature": segment.temperature,
        "avg_logprob": segment.avg_logprob,
        "compression_ratio": segment.compression_ratio,
        "no_speech_prob": segment.no_speech_prob,
        "id": segment.id,
        "words": [jsonify_word(word) for word in segment.words]
    }


def format_transcription(segments, info):
    """
    Format the transcription from faster-whisper into the required format for stable-ts inference
    https://colab.research.google.com/drive/1dOu-6elaUKBDTOWhzIWWxQosWYjqjpiE (stable-ts inference for any ASR)
    Refer to full_mapping
    """
    language = info.language
    text = concatenate_segments(segments)
    segments = [jsonify_segment(segment) for segment in segments]
    return {
        "language": language,
        "text": text,
        "segments": segments
    }


def extract_speaker_id(speaker_label):
    # For labels generated by the sequential transcription
    try:
        # Extract the speaker number (last two characters of the input string) and convert to int
        speaker_number = int(speaker_label[-2:])
        return speaker_number
    except (ValueError, TypeError) as e:
        return -1